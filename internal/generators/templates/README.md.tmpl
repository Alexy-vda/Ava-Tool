# {{.ServiceName}}

This is a scaffolded Go microservice, generated by Ava-Tool. It's designed with best practices in mind, favoring a clean architecture inspired by the **Repository Pattern** and **Dependency Injection**.

## Project Structure

-   `cmd/{{.ServiceName}}`: The entry point of your application.
-   `internal/api/handlers`: Contains HTTP request handlers. These should be thin, delegating business logic to services.
-   `internal/api/routers`: Defines HTTP routes and their mapping to handlers.
-   `internal/configs`: Handles application configuration (e.g., environment variables).
-   `internal/db`: Database connection initialization and migration logic.
-   `internal/helpers`: Utility functions and helper methods.
-   `internal/models`: Defines data structures (structs) for your application entities.
-   `internal/repositories`: **(Repository Pattern)** Defines interfaces for data access operations and their implementations (e.g., GORM-specific implementations).
-   `internal/server`: Contains the HTTP server setup and middlewares.
-   `internal/services`: **(Business Logic Layer)** Implements the core business logic, orchestrating calls to repositories.

## Implementing the Repository Pattern

The `internal/repositories` and `internal/services` directories are crucial for implementing a clean, testable, and maintainable architecture.

1.  **Define your Models (`internal/models`)**:
    *   Create structs representing your entities (e.g., `User`, `Product`).
    *   Embed `BaseModel` for common fields like `ID`, `CreatedAt`, `UpdatedAt`.

    ```go
    // internal/models/user.go
    package models

    type User struct {
        BaseModel
        Name  string
        Email string `gorm:"unique"`
    }
    ```

2.  **Define Repository Interfaces (`internal/repositories`)**:
    *   Create an interface for each entity that needs data persistence. This interface defines *what* data operations can be performed, without knowing *how* they are performed.

    ```go
    // internal/repositories/user_repository.go
    package repositories

    import "{{.ServiceName}}/internal/models" // Replace 'your-module-name'

    type UserRepository interface {
        FindByID(id uint) (*models.User, error)
        FindAll() ([]models.User, error)
        Save(user *models.User) error
        Delete(id uint) error
    }
    ```

3.  **Implement Repository (`internal/repositories`)**:
    *   Create a struct that implements your repository interface, using `gorm.DB` for actual database interaction.

    ```go
    // internal/repositories/gorm_user_repository.go
    package repositories

    import (
        "{{.ServiceName}}/internal/models" // Replace 'your-module-name'
        "gorm.io/gorm"
    )

    type gormUserRepository struct {
        db *gorm.DB
    }

    func NewGormUserRepository(db *gorm.DB) UserRepository {
        return &gormUserRepository{db: db}
    }

    func (r *gormUserRepository) FindByID(id uint) (*models.User, error) {
        var user models.User
        if err := r.db.First(&user, id).Error; err != nil {
            return nil, err
        }
        return &user, nil
    }
    // Implement other methods...
    ```

4.  **Define Service Interfaces (`internal/services`)**:
    *   Create an interface for each domain-specific service. This interface defines *what* business operations can be performed. Services use repositories via their interfaces.

    ```go
    // internal/services/user_service.go
    package services

    import (
        "{{.ServiceName}}/internal/models"      // Replace 'your-module-name'
        "{{.ServiceName}}/internal/repositories" // Replace 'your-module-name'
    )

    type UserService interface {
        GetUser(id uint) (*models.User, error)
        CreateUser(name, email string) (*models.User, error)
        // Other business operations...
    }
    ```

5.  **Implement Service (`internal/services`)**:
    *   Create a struct that implements your service interface. It will receive a repository interface (dependency injection).

    ```go
    // internal/services/user_service_impl.go
    package services

    import (
        "{{.ServiceName}}/internal/models"      // Replace 'your-module-name'
        "{{.ServiceName}}/internal/repositories" // Replace 'your-module-name'
    )

    type userService struct {
        userRepo repositories.UserRepository
    }

    func NewUserService(userRepo repositories.UserRepository) UserService {
        return &userService{userRepo: userRepo}
    }

    func (s *userService) GetUser(id uint) (*models.User, error) {
        return s.userRepo.FindByID(id)
    }
    // Implement other business logic...
    ```

6.  **Create Handlers (`internal/api/handlers`)**:
    *   Handlers receive HTTP requests, call the appropriate service methods, and return responses. They should receive a service interface (dependency injection).

    ```go
    // internal/api/handlers/user_handler.go
    package handlers

    import (
        "{{.ServiceName}}/internal/services" // Replace 'your-module-name'
        "github.com/gin-gonic/gin"
        "net/http"
        "strconv"
    )

    type UserHandler struct {
        userService services.UserService
    }

    func NewUserHandler(userService services.UserService) *UserHandler {
        return &UserHandler{userService: userService}
    }

    func (h *UserHandler) GetUserByID(c *gin.Context) {
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 64)
        if err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
            return
        }

        user, err := h.userService.GetUser(uint(id))
        if err != nil {
            c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
            return
        }
        c.JSON(http.StatusOK, user)
    }
    ```

7.  **Wire Everything Up (`internal/api/routers` or `cmd/{{.ServiceName}}/main.go`)**:
    *   In your `main.go` or router setup, instantiate your GORM database, then create repository implementations, then service implementations, and finally handler instances, injecting their dependencies.

    ```go
    // Example in cmd/{{.ServiceName}}/main.go
    package main

    import (
        "{{.ServiceName}}/internal/api/handlers"
        "{{.ServiceName}}/internal/api/routers"
        "{{.ServiceName}}/internal/configs"
        "{{.ServiceName}}/internal/db"
        "{{.ServiceName}}/internal/repositories"
        "{{.ServiceName}}/internal/server"
        "{{.ServiceName}}/internal/services"
        "log"
    )

    func main() {
        config := configs.LoadConfig()
        s := server.NewServer(config)

        // DB setup
        db.InitDB()
        db.MigrateDB() // Ensure models are migrated

        // Instantiate repositories
        userRepo := repositories.NewGormUserRepository(db.GetDB())

        // Instantiate services
        userService := services.NewUserService(userRepo)

        // Instantiate handlers
        userHandler := handlers.NewUserHandler(userService)

        // Register specific routes
        routers.RegisterSpecificRoutes(s.Router, userHandler) // Modify routers.RegisterRoutes

        if err := s.Start(); err != nil {
            log.Fatalf("Failed to start server: %v", err)
        }
    }
    ```
    *Note: This `main.go` example shows how to wire. You would need to adapt `routers.RegisterRoutes` to accept handlers.*

---

## Getting Started

1.  **Navigate** into your new service directory: `cd {{.ServiceName}}`
2.  **Define** your `internal/models`.
3.  **Implement** your `internal/repositories` (interfaces and GORM implementations).
4.  **Implement** your `internal/services` (interfaces and business logic).
5.  **Create** your `internal/api/handlers` and wire them up in `internal/api/routers` or directly in `cmd/{{.ServiceName}}/main.go`.
6.  **Update `internal/db/migration.go`** to include your new models for `AutoMigrate`.
7.  **Build and Run**:
    ```bash
    docker-compose up --build
    ```
    Or locally:
    ```bash
    go mod tidy
    go run ./cmd/{{.ServiceName}}
    ```
{{if .IncludePrometheus}}
## Prometheus Metrics

If you chose to include Prometheus metrics, your service will expose metrics on the `/metrics` endpoint.
You can access these metrics at `http://localhost:{{.Port}}/metrics`.

To integrate with a Prometheus server, configure it to scrape this endpoint.
{{end}}
{{if .IncludeSwagger}}
## Swagger Documentation

If you chose to include Swagger documentation, the `/swagger/*any` endpoint is configured to serve your API documentation.

**To generate and view your API docs:**

1.  **Install Swag CLI**:
    ```bash
    go install github.com/swaggo/swag/cmd/swag@latest
    ```
2.  **Add annotations to your Go code**: Use `// @Summary`, `// @Param`, `// @Success`, etc., in your handler functions.
    *   **Important**: You'll need to add basic Swagger annotations to your `cmd/{{.ServiceName}}/main.go` file (e.g., `@title`, `@version`, `@host`, `@BasePath`).
3.  **Generate the Swagger documentation**:
    ```bash
    swag init -g cmd/{{.ServiceName}}/main.go
    ```
    This command will generate the `docs` folder with `docs.go`, `swagger.json`, and `swagger.yaml`.
4.  **Add the `docs` import**: In your `cmd/{{.ServiceName}}/main.go` file, add the following import (if not already present):
    ```go
    // This line is crucial for Swagger to find your generated docs
    import _ "{{.ServiceName}}/docs" 
    ```
    (Note: If this line causes a compilation error before `swag init` is run, you might need to comment it out temporarily.)
5.  **Restart your service**.
6.  **Access the docs**: Open your browser to `http://localhost:{{.Port}}/swagger/index.html`.
{{end}}

This `README.md` template guides the user through implementing the pattern. The placeholders `your-module-name` will be replaced with `{{.ServiceName}}` by the templating engine.
